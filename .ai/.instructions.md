# NgTimeTrack Copilot Instructions

## Project Overview

NgTimeTrack is a modern web-based time tracking application designed to replace manual Excel-based tracking of working hours. It allows users to log time spent on tasks, projects, or clients in real-time or manually, generate reports, and export data. The app is built as a full-stack application using Angular 20 with NgRx SignalStore for state management on the frontend and Spring Boot for the backend. It supports tracking of vacation days and integrates with Element (a Matrix-based Slack alternative) for notifications.

### Key Features

- **User Authentication and Authorization**: Secure login/signup with email/password, role-based access (Employee, HR, Admin).
- **Time Tracking**: Real-time timer and manual entry with categorization by projects, clients, and tags.
- **Vacation and Leave Tracking**: Request submission, approval workflow, calendar view, and accrual tracking (30 days/year per employee).
- **Dashboard**: Overview of tracked time, recent entries, vacation balance; HR view for employee reports.
- **Projects and Clients Management**: CRUD operations with user assignments.
- **Reports and Analytics**: Filtered reports with export options (CSV, PDF, Excel).
- **Notifications and Integrations**: Reminders via Element integration.

### Version and Stakeholders

- **Version**: 1.1 (Updated Release)
- **Date**: September 01, 2025
- **Stakeholders**: Product Owner, Development Team (Frontend: Angular/NgRx, Backend: Spring Boot), Users: ~40 employees (Employees, HR, Admins).

## Tech Stack

### Frontend

- **Framework**: Angular 20
- **State Management**: NgRx SignalStore
- **UI Library**: Angular Material
- **Charts**: ngx-charts or Angular Material chart components
- **Forms**: Angular Reactive Forms
- **HTTP**: Angular HttpClient
- **Authentication**: Angular OAuth2 OIDC
- **Image Optimization**: NgOptimizedImage
- **Testing**: Vitest (migrated from Karma for Angular 20 compatibility)

### Backend

- **Framework**: Spring Boot (Java)
- **ORM**: Spring Data JPA (with Hibernate)
- **Database**: PostgreSQL
- **Authentication**: Spring Security with JWT
- **PDF/Excel Export**: iText (PDF), Apache POI (Excel)
- **Notifications**: Matrix Java SDK (for Element integration)
- **API**: RESTful (JSON)
- **Testing**: JUnit 5, Spring Boot Test, JaCoCo

### DevOps & Deployment

- **CI/CD**: GitHub Actions
- **Hosting**: On-premise server
- **Containerization**: Docker (optional)
- **Monitoring/Logging**: ELK Stack (Elasticsearch, Logstash, Kibana)

### Other

- **Documentation**: OpenAPI/Swagger (backend API), Storybook (optional for UI components)
- **Email**: Spring Boot Mail or SendGrid API

## Architecture Overview

### Monorepo Structure

The repository is organized as a monorepo with the following main folders:

- `frontend/`: Contains the Angular 20 application. All UI, client-side logic, and static assets reside here. Entry point: `frontend/src/main.ts`.
- `backend/`: Contains the Spring Boot application. All API endpoints, business logic, and database integration are here. Entry point: `backend/src/main/java/com/jeromewirth/backend/BackendApplication.java`.
- `.ai/`: Contains AI-generated documentation, requirements, tech stack, implementation plans, progress logs, and architectural notes for future developers.
- `.github/workflows/ci.yml`: GitHub Actions workflow for continuous integration. Runs build and tests for both frontend and backend on every push or pull request.
- `.gitignore`: Root ignore file for Node, Java, and system/IDE files.

### Backend Architecture

- **Packages**: `com.jeromewirth.backend.model` (JPA entities), `com.jeromewirth.backend.repository` (JPA repositories), `com.jeromewirth.backend.service` (business logic), `com.jeromewirth.backend.controller` (REST controllers), `com.jeromewirth.backend.config` (SecurityConfig, AuthTokenFilter, JwtUtils).
- **Key Components**: Entities (User, TimeEntry, Project, Client, VacationDay), Repositories, Controllers, Security (JWT-based), Configuration.
- **Database Schema**: PostgreSQL with tables for users, clients, projects, time_entries, vacation_days, user_projects.

### Frontend Architecture

- **Component Structure**: LayoutComponent (main layout), Authentication Components (LoginComponent, RegisterComponent), Feature Components (DashboardComponent, TimeEntryComponent, ProjectsComponent, ClientsComponent, VacationsComponent).
- **Routing**: Hierarchical with lazy loading potential.
- **State Management**: NgRx SignalStore (AuthStore, TimeEntryStore, ProjectStore, VacationStore).
- **Services**: AuthService, TimeEntryService, ProjectService, VacationService, with HTTP interceptor for JWT.
- **UI/UX**: Angular Material with dark theme, responsive design.

### CI/CD

- `.github/workflows/ci.yml` runs two jobs: frontend (install, build, test), backend (install, build, test).

## Current State (Progress Log)

### Completed Steps

- **Step 1 (Project Setup)**: Monorepo structure, Angular 20 frontend with Material/NgRx, Spring Boot backend with PostgreSQL/Security, CI/CD with GitHub Actions.
- **Step 2 (Database & Backend Foundation)**: JPA entities, JWT authentication, CRUD for TimeEntry/Project/Client/VacationDay, role-based access.
- **Step 3 (Frontend Foundation)**: Routing, base layout, authentication flow, TimeEntry/Project/Client/Vacation UI.
- **Step 4 (State Management & API Integration)**: NgRx SignalStore setup, UI-backend connection, HTTP interceptor.
- **Step 5 (Basic Dashboard)**: Employee dashboard (total hours, recent entries, vacation balance), HR dashboard (employee overview, report status), sample data loader, UI enhancements.
- **Step 6 (Testing & Validation)**: Backend tests (JUnit, JaCoCo >70% coverage), Frontend migration to Vitest (resolved Angular 20 conflicts), all tests passing.

### Ready for Next Steps

- Step 7: Documentation updates.
- Step 8: Review & Handover.

## Implementation Plan (Base Version)

### Key Clarifications

- **Roles**: Employee (own data), HR (projects/clients, all time/vacation data), Admin (users, system settings).
- **Time Entry**: Required fields: project, client, start/end time, description. Manual/timer-based.
- **Vacation Days**: 30/year per employee. Employees see own; HR sees all with calendar.
- **Testing**: >70% coverage for frontend/backend.
- **API Documentation**: Swagger/OpenAPI required.
- **CI/CD**: Build/test only (no deploy).

### Remaining Steps

- **Step 7: Documentation**: Update READMEs, ensure Swagger docs.
- **Step 8: Review & Handover**: Peer review, confirm all features/tests pass.

## Best Practices

### TypeScript & Angular Best Practices

- Use strict type checking.
- Prefer type inference when obvious.
- Avoid `any`; use `unknown` for uncertain types.
- Always use standalone components over NgModules.
- Do NOT set `standalone: true` in decorators (default).
- Use signals for state management.
- Implement lazy loading for feature routes.
- Do NOT use `@HostBinding`/`@HostListener`; put host bindings in `host` object of `@Component`/`@Directive`.
- Use `NgOptimizedImage` for static images (not base64).
- Keep components small and focused.
- Use `input()`/`output()` instead of decorators.
- Use `computed()` for derived state.
- Set `changeDetection: ChangeDetectionStrategy.OnPush`.
- Prefer inline templates for small components.
- Use Reactive Forms over Template-driven.
- Do NOT use `ngClass`/`ngStyle`; use class/style bindings.
- Use native control flow (`@if`, `@for`, `@switch`) over `*ngIf`, etc.
- Use async pipe for observables.
- Use `inject()` instead of constructor injection.
- Keep templates simple; avoid complex logic.

### Spring Boot & Java Best Practices

- Use Spring Boot starters for dependencies.
- Follow RESTful API conventions.
- Use JPA annotations for entities; avoid manual SQL where possible.
- Implement proper exception handling with `@ControllerAdvice`.
- Use `@PreAuthorize` for role-based security.
- Validate inputs with Bean Validation (`@Valid`, `@NotNull`, etc.).
- Use DTOs for API responses to avoid exposing entities.
- Implement pagination for list endpoints.
- Use logging with SLF4J.
- Write unit tests for services/repositories, integration tests for controllers.
- Ensure >70% code coverage with JaCoCo.
- Use H2 for testing; PostgreSQL for production.

### General Best Practices

- Follow monorepo structure; keep frontend/backend separate.
- Use Git for version control; commit frequently with descriptive messages.
- Run tests before pushing; ensure CI passes.
- Document APIs with Swagger; update READMEs.
- Handle errors gracefully; provide user-friendly messages.
- Optimize for performance: lazy loading, efficient queries, caching.
- Ensure accessibility (WCAG 2.1) and responsiveness.
- Use environment variables for secrets (JWT keys, DB credentials).
- Backup database regularly; implement monitoring.

## Roles and Permissions

- **Employee**: Manage own time entries, view own vacation balance, assign to projects.
- **HR**: Manage projects/clients, view all time/vacation data, approve vacations, see employee reports.
- **Admin**: Manage users, system settings, full access.

## How to Contribute

1. **Setup**: Clone repo, run `npm install` in frontend, `./gradlew build` in backend.
2. **Development**: Work in respective folders; use VS Code for editing.
3. **Testing**: Run `npm test` (frontend), `./gradlew test` (backend).
4. **CI/CD**: Push to main; GitHub Actions will build/test.
5. **Documentation**: Update .ai files for changes; ensure Swagger for APIs.
6. **Review**: Follow implementation plan; validate with tests.

This document serves as the perfect starting point for Copilot to understand, maintain, and extend NgTimeTrack effectively.
